## 从点云信息生成局部栅格地图

1. 获取点云信息
2. 点云分割
3. 局部地图构建
4. 持续更新栅格地图



从/map/vector_map_marker获取的信息：

```c++
ns: lanelet_id
  id: 367
  type: 9 // 表示不同的lanelet元素类型
  action: 0
  pose:
    position:
      x: -42.875150000000005
      y: 11.0444
      z: 0.42010000000000003
    orientation:
      x: 0.0
      y: 0.0
      z: 0.0
      w: 1.0
  scale:
    x: 0.0
    y: 0.0
    z: 0.5
  color:
    r: 0.5
    g: 0.5
    b: 0.5
    a: 0.9990000128746033
  lifetime:
    sec: 0
    nanosec: 0
  frame_locked: false
  points: []
  colors: []
  texture_resource: ''
  texture:
    header:
      stamp:
        sec: 0
        nanosec: 0
      frame_id: ''
    format: ''
    data: []
  uv_coordinates: []
  text: '367'
  mesh_resource: ''
  mesh_file:
    filename: ''
    data: []
  mesh_use_embedded_materials: false
- header:
    stamp:
      sec: 1721265728
      nanosec: 603116294
    frame_id: map
```

插值：通过一系列的点来构造一条符合这些点的平滑曲线

lanelet中的交通灯、指示牌都采用线串来表示，线串占据指示灯位置，线串属性表示指示类型以及状态。

lanelet的地图投影是将现实中的三维信息投影到平面上。

两个id信息包之间的id差异是这一个信息包所包含的lanelet数？

lanelet的中心线：lanelet是一条道路，机器人要沿着lanelet的中心线走，而不能随便走。

显式构造函数：使用explicit来进行定义，作用是避免用户进行隐式转换，构造对象时必须完整地将构造函数写出，这样可以避免数据类型转换。

```c++
class A {
public:
    explicit A(int x) {
        // 构造函数的实现
    }
};

int main() {
    // 如果A(int x)没有explicit关键字就是对的。
    A obj1 = 5;  // 编译错误，因为构造函数是显式的，不能进行隐式转换
    A obj2(5);   // 正确，显式调用构造函数来创建对象
    return 0;
}

```

将一个类放到一个namespace中，可以避免命名冲突。

```c++
namespace global_planner_server {

class GlobalPlanner {
public:
    void plan() {
        // 实现路径规划的逻辑
    }
};
} 
// 这样在上述示例中，GlobalPlanner 类被定义在 global_planner_server 命名空间中。这意味着在使用该类时，需要通过 global_planner_server::GlobalPlanner 来访问它。
```

引用计数机制：智能指针可以记录有多少个对象正在使用该指针所指向的资源，当引用计数为0时，就可以考虑一种策略来将该指针删除。

循环引用导致内存泄漏问题：两个对象共同同时使用对方智能指针所指向的资源，导致这两个资源的引用计数永远不能为0，即永远无法被释放，最终会导致内存泄漏问题。

内存泄漏：系统资源浪费或内存耗尽的问题。

弱指针：弱指针可以指向一个share_ptr指向的资源而不增加其引用次数，可以避免循环引用问题。

点云地图的体素：体素相当于三维空间中的像素，体素越小空间信息越精细，但计算量也会相应增大。

查看pcd结尾的点云文件：pcl_viewer <文件名>.pcd



点云信息话题：/points_map
lanelet信息话题：/map/vector_map
lanelet信息可视化话题：/map/vector_map_marker

vscode折叠所有代码块：ctrl+k 然后ctrl+0
vscode展开所有代码块：ctrl+k 然后ctrl+j

## 全局规划调用了什么数据，怎么进行全局规划？

mapping_msgs::msg::HADMapBin：用于保存lanelet地图数据类型
lanelet2Planner的configure函数中订阅了/map/vector_map话题，并将信息用CallbackHDMap函数保存到route_handler\_对象中
route_handle是全局规划的主要函数。

## 局部规划调用了什么数据？

局部规划使用了全局规划生成的lanelet路径，再接收点云地图信息来进行规划。

```c++
// 大括号作用域来限定代码块，有什么作用？
    {
        // std::lock_guard<std::mutex> data_lk(data_lock_);
        if (!localization_received_)
        {
            RCLCPP_WARN_THROTTLE(get_logger(),*get_clock(), 5000, "Missing msf status");
            update_ = true;
            return;
        }         
        if (!pointcloud_received_)
        {
            RCLCPP_WARN_THROTTLE(get_logger(),*get_clock(), 5000, "Missing point cloud");
            update_ = true;
            return;
        }
    }
```

点云数据内部组成

```c++
// 创建一个点云对象
// 一个点云对象中可以保存很多个pcl::PointXYZI的对象
    pcl::PointCloud<pcl::PointXYZI>::Ptr cloud(new pcl::PointCloud<pcl::PointXYZI>);

    // 添加点到点云中
    pcl::PointXYZI point;
    point.x = 1.0;
    point.y = 2.0;
    point.z = 3.0;
    point.intensity = 100.0; // 表示该点的强度信息
    cloud->push_back(point);
```

点云信息如何被裁剪？裁剪出来的左右边界是什么？为什么只裁剪左右边界？
全局路径为什么会有左右边界？是基于lanelet的边界吗？

1. 裁剪出来的点云信息是一个只有x和y数据的点云对象
2. 裁剪基于规划出来的全局路径进行，该全局路径应该是一个类似于lanelet的数据，包含了道路的左右边界（对应到二维平面中就是xy坐标系）。
3. 裁剪时，通过计算机器人的位置相对道路左右边界的距离来选择或不选择某些点。最终被选择的点的整体构成了边界的点。
4. 为什么只裁剪左右边界，因为只需要计算左右边界到机器人的距离就能自动对机器人前后方向的点云进行裁剪。

点云裁剪后的起始索引和结束索引如何确定？

栅格地图的分辨率：一个像素代表现实世界的多大区域。10米分辨率的地图意味着地图上的每个像素对应10米*10米的地面区域。

Eigen库：用于进行线性代数计算的库
Vector3d：Eigen库中一个用于保存三个双精度浮点数的向量，方便对该向量进行计算

坐标系变换不需要坐标系平移，因为车体在运动时，周围环境也会跟着运动，所以环境坐标系不需要作平移。
坐标系变换应该是将机器人当前的角度转换成世界坐标系，而不是将点云转到机器人坐标系中。
基于右手坐标系，作逆变换就得到程序中的结果。

地图分辨率和逆分辨率：
分辨率是指：一个像素所代表的空间大小
逆分辨率是指：一单位空间中所包含的像素数量

ceil()：对每个数进行向上取整数，是Eigen库中的内容
floor()：向下取整数

类中属性在末尾加上下划线，传入的参数不需要下划线

获取点云中点的数量：
`pc_obs->points.size()` 是直接获取点云中点的数量。
`pc_obs->size()` 通常用来获取指针指向的对象（即 `PointCloud` 对象）的大小，包括其中存储的点的数量，但它也可能用来表示其他数据结构的大小或容量。

C++函数的內联展开：
在函数最前面加上`inline`关键字，这个函数就会写入到任何调用它的地方，就不需要进行函数的调用，不需要保护和恢复现场，以提高执行速度；內联函数需要在头文件中写好，这样可以避免重定义。
PS：內联只适用于代码量较少的函数，是否內联实际上由编译器决定。
